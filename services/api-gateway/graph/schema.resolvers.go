package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"
	"fmt"

	feedv1 "github.com/jupiterclapton/cenackle/gen/feed/v1"
	identityv1 "github.com/jupiterclapton/cenackle/gen/identity/v1"
	postv1 "github.com/jupiterclapton/cenackle/gen/post/v1"
	"github.com/jupiterclapton/cenackle/services/api-gateway/graph/model"
	"github.com/jupiterclapton/cenackle/services/api-gateway/internal/auth"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	// 1. Appel gRPC vers Identity Service
	resp, err := r.IdentityClient.Register(ctx, &identityv1.RegisterRequest{
		Email:    input.Email,
		Username: input.Username,
		Password: input.Password,
		FullName: input.FullName,
	})
	if err != nil {
		return nil, err // TODO: Mapper les erreurs gRPC vers des erreurs GraphQL propres
	}

	// 2. Mapping de la réponse Proto -> GraphQL
	return &model.AuthPayload{
		User:         mapProtoUserToGraph(resp.User),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
		ExpiresIn:    int(resp.ExpiresInSeconds),
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// On peut récupérer l'IP et le UserAgent depuis le contexte HTTP ici si besoin
	resp, err := r.IdentityClient.Login(ctx, &identityv1.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		User:         mapProtoUserToGraph(resp.User),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
		ExpiresIn:    int(resp.ExpiresInSeconds),
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, token string) (*model.AuthPayload, error) {
	// 1. Appel gRPC : Renouvellement des tokens
	refreshResp, err := r.IdentityClient.RefreshToken(ctx, &identityv1.RefreshTokenRequest{
		RefreshToken: token,
	})
	if err != nil {
		// L'erreur gRPC sera propagée (ex: "invalid token" ou "expired")
		return nil, err
	}

	// 2. Récupération de l'utilisateur (Solution de contournement)
	// Comme notre réponse gRPC RefreshToken ne contient pas l'objet User,
	// nous devons le récupérer manuellement en utilisant le token tout neuf.

	// Étape A : Extraire l'ID via validation
	valResp, err := r.IdentityClient.ValidateToken(ctx, &identityv1.ValidateTokenRequest{
		Token: refreshResp.AccessToken,
	})
	if err != nil || !valResp.IsValid {
		return nil, errors.New("internal error: generated token validation failed")
	}

	// Étape B : Charger le profil complet
	userResp, err := r.IdentityClient.GetUser(ctx, &identityv1.GetUserRequest{
		UserId: valResp.UserId,
	})
	if err != nil {
		return nil, err
	}

	// 3. Construction de la réponse GraphQL
	return &model.AuthPayload{
		User:         mapProtoUserToGraph(userResp.User),
		AccessToken:  refreshResp.AccessToken,
		RefreshToken: refreshResp.RefreshToken,
		ExpiresIn:    int(refreshResp.ExpiresInSeconds),
	}, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.User, error) {
	// 1. Récupération de l'ID utilisateur depuis le contexte (Middleware)
	userID := auth.ForContext(ctx)
	if userID == nil {
		return nil, errors.New("unauthorized: you must be logged in")
	}

	// 2. Appel gRPC
	// Note : Les pointeurs Input GraphQL (*string) mappent bien vers les pointeurs Protobuf Optional que nous avons définis
	resp, err := r.IdentityClient.UpdateProfile(ctx, &identityv1.UpdateProfileRequest{
		UserId:   userID.ID,
		FullName: input.FullName,
		Email:    input.Email,
	})
	if err != nil {
		return nil, err
	}

	return mapProtoUserToGraph(resp.User), nil
}

// Author is the resolver for the author field.
func (r *postResolver) Author(ctx context.Context, obj *model.Post) (*model.User, error) {
	// 1. On récupère l'ID qu'on a stocké à l'étape précédente
	authorID := obj.AuthorID

	// 2. Appel au Identity Service
	// Note : Pour l'instant on fait 1 appel par Post (N+1 problem).
	// Dans une version "Ultra Expert", on utiliserait un "DataLoader" ici.
	// Mais pour aujourd'hui, c'est très bien comme ça.
	resp, err := r.IdentityClient.GetUser(ctx, &identityv1.GetUserRequest{
		UserId: authorID,
	})

	if err != nil {
		// En cas d'erreur (auteur supprimé ?), on log mais on ne casse pas tout.
		// On renvoie une erreur ou un utilisateur "inconnu"
		return &model.User{ID: authorID, Username: "Unknown"}, nil
	}

	// 3. Mapping via ton helper (dans mappers.go)
	return mapProtoUserToGraph(resp.User), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID := auth.ForContext(ctx)
	if userID == nil {
		return nil, errors.New("unauthorized: you must be logged in")
	}

	// Appel gRPC GetUser
	resp, err := r.IdentityClient.GetUser(ctx, &identityv1.GetUserRequest{
		UserId: userID.ID,
	})
	if err != nil {
		return nil, err
	}

	return mapProtoUserToGraph(resp.User), nil
}

// Feed is the resolver for the feed field.
// Feed récupère la timeline (IDs) puis hydrate le contenu (Posts)
func (r *queryResolver) Feed(ctx context.Context, limit *int, offset *int) ([]*model.Post, error) {
	// 1. Récupérer l'ID utilisateur depuis le contexte (JWT Middleware)
	// (Assumons que vous avez une fonction helper pour ça, sinon hardcodez pour le test)
	// userID := middleware.GetUserID(ctx)
	//userID := "user-trinity-uuid" // ⚠️ TEMPORAIRE POUR TESTER RAPIDEMENT
	user := auth.ForContext(ctx)
	if user == nil { // ✅ Correct car 'user' est un pointeur de struct
		return nil, fmt.Errorf("access denied")
	}
	userID := user.ID

	// Valeurs par défaut
	l := int32(20)
	if limit != nil {
		l = int32(*limit)
	}
	o := int32(0)
	if offset != nil {
		o = int32(*offset)
	}

	// 2. Appel Feed Service (Récupère les IDs)
	timelineResp, err := r.FeedClient.GetTimeline(ctx, &feedv1.GetTimelineRequest{
		UserId: userID,
		Limit:  l,
		Offset: o,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch timeline: %w", err)
	}

	if len(timelineResp.Items) == 0 {
		return []*model.Post{}, nil
	}

	// 3. Extraction des IDs de posts
	postIDs := make([]string, len(timelineResp.Items))
	for i, item := range timelineResp.Items {
		postIDs[i] = item.PostId
	}

	// 4. Appel Post Service (Batch Hydration - Récupère le contenu)
	postsResp, err := r.PostClient.GetPosts(ctx, &postv1.GetPostsRequest{
		PostIds: postIDs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch posts content: %w", err)
	}

	// 5. Mapping Proto -> GraphQL
	// Note: On ne mappe pas 'Author' ici, on laisse le resolver Post.Author le faire (voir plus bas)
	gqlPosts := make([]*model.Post, len(postsResp.Posts))
	for i, p := range postsResp.Posts {
		gqlPosts[i] = &model.Post{
			ID:       p.Id,
			AuthorID: p.AuthorId, // ✅ On passe l'ID pour le resolver suivant
			Content:  p.Content,

			// ✅ CORRECTION TIME : On passe l'objet time.Time direct.
			// gqlgen fera le Marshal vers JSON string tout seul.
			CreatedAt: p.CreatedAt.AsTime(),
			UpdatedAt: p.UpdatedAt.AsTime(),

			Media: mapProtoMediaToGraph(p.Media),

			// ⚠️ IMPORTANT : On NE remplit PAS Author ici !
			// Le champ Author sera vide (nil) à cette étape, et c'est normal.
		}
	}

	return gqlPosts, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"
	"time"

	identityv1 "github.com/jupiterclapton/cenackle/gen/identity/v1"
	"github.com/jupiterclapton/cenackle/services/api-gateway/graph/model"
	"github.com/jupiterclapton/cenackle/services/api-gateway/internal/auth"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	// 1. Appel gRPC vers Identity Service
	resp, err := r.IdentityClient.Register(ctx, &identityv1.RegisterRequest{
		Email:    input.Email,
		Username: input.Username,
		Password: input.Password,
		FullName: input.FullName,
	})
	if err != nil {
		return nil, err // TODO: Mapper les erreurs gRPC vers des erreurs GraphQL propres
	}

	// 2. Mapping de la réponse Proto -> GraphQL
	return &model.AuthPayload{
		User:         mapProtoUserToGraph(resp.User),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
		ExpiresIn:    int(resp.ExpiresInSeconds),
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// On peut récupérer l'IP et le UserAgent depuis le contexte HTTP ici si besoin
	resp, err := r.IdentityClient.Login(ctx, &identityv1.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		User:         mapProtoUserToGraph(resp.User),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
		ExpiresIn:    int(resp.ExpiresInSeconds),
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, token string) (*model.AuthPayload, error) {
	// 1. Appel gRPC : Renouvellement des tokens
	refreshResp, err := r.IdentityClient.RefreshToken(ctx, &identityv1.RefreshTokenRequest{
		RefreshToken: token,
	})
	if err != nil {
		// L'erreur gRPC sera propagée (ex: "invalid token" ou "expired")
		return nil, err
	}

	// 2. Récupération de l'utilisateur (Solution de contournement)
	// Comme notre réponse gRPC RefreshToken ne contient pas l'objet User,
	// nous devons le récupérer manuellement en utilisant le token tout neuf.

	// Étape A : Extraire l'ID via validation
	valResp, err := r.IdentityClient.ValidateToken(ctx, &identityv1.ValidateTokenRequest{
		Token: refreshResp.AccessToken,
	})
	if err != nil || !valResp.IsValid {
		return nil, errors.New("internal error: generated token validation failed")
	}

	// Étape B : Charger le profil complet
	userResp, err := r.IdentityClient.GetUser(ctx, &identityv1.GetUserRequest{
		UserId: valResp.UserId,
	})
	if err != nil {
		return nil, err
	}

	// 3. Construction de la réponse GraphQL
	return &model.AuthPayload{
		User:         mapProtoUserToGraph(userResp.User),
		AccessToken:  refreshResp.AccessToken,
		RefreshToken: refreshResp.RefreshToken,
		ExpiresIn:    int(refreshResp.ExpiresInSeconds),
	}, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.User, error) {
	// 1. Récupération de l'ID utilisateur depuis le contexte (Middleware)
	userID := auth.ForContext(ctx)
	if userID == "" {
		return nil, errors.New("unauthorized: you must be logged in")
	}

	// 2. Appel gRPC
	// Note : Les pointeurs Input GraphQL (*string) mappent bien vers les pointeurs Protobuf Optional que nous avons définis
	resp, err := r.IdentityClient.UpdateProfile(ctx, &identityv1.UpdateProfileRequest{
		UserId:   userID,
		FullName: input.FullName,
		Email:    input.Email,
	})
	if err != nil {
		return nil, err
	}

	return mapProtoUserToGraph(resp.User), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID := auth.ForContext(ctx)
	if userID == "" {
		return nil, errors.New("unauthorized: you must be logged in")
	}

	// Appel gRPC GetUser
	resp, err := r.IdentityClient.GetUser(ctx, &identityv1.GetUserRequest{
		UserId: userID,
	})
	if err != nil {
		return nil, err
	}

	return mapProtoUserToGraph(resp.User), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// --- HELPERS ---

// --- HELPERS ---

func mapProtoUserToGraph(u *identityv1.User) *model.User {
	if u == nil {
		return nil
	}

	// Gestion sécurisée des dates (pour éviter le Nil Pointer Dereference)
	var createdAt time.Time
	if u.CreatedAt != nil {
		createdAt = u.CreatedAt.AsTime()
	}

	var updatedAt time.Time
	if u.UpdatedAt != nil {
		updatedAt = u.UpdatedAt.AsTime()
	}

	return &model.User{
		ID:        u.Id,
		Email:     u.Email,
		Username:  u.Username,
		FullName:  u.FullName,
		IsActive:  u.IsActive,
		CreatedAt: createdAt, // Utilisation de la variable sécurisée
		UpdatedAt: updatedAt, // Utilisation de la variable sécurisée
	}
}
